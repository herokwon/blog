name: Issue Auto-Format and Labeling
on:
  issues:
    types: [opened]

permissions:
  issues: write

env:
  GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  ISSUE_NUMBER: ${{ github.event.issue.number }}
  ISSUE_TITLE: ${{ github.event.issue.title }}

jobs:
  initialize-processing:
    name: Initialize processing
    runs-on: ubuntu-latest
    outputs:
      comment-id: ${{ steps.comment.outputs.id }}
      category: ${{ steps.category.outputs.result }}
    steps:
      - name: Check issue category
        id: category
        run: |
          if [[ "${{ env.ISSUE_TITLE }}" == *"[Bug]"* ]] || [[ "$(echo ${{ github.event.issue.labels.*.name }} | grep -o 'BugFix')" == "BugFix" ]]; then
            echo "result=bug-report" >> $GITHUB_OUTPUT
          elif [[ "${{ env.ISSUE_TITLE }}" == *"[Feature]"* ]] || [[ "$(echo ${{ github.event.issue.labels.*.name }} | grep -o 'Feature')" == "Feature" ]]; then
            echo "result=feature-request" >> $GITHUB_OUTPUT
          else
            echo "result=general" >> $GITHUB_OUTPUT
          fi

      - name: Add initial comment
        id: comment
        run: |
          COMMENT_URL=$(gh issue comment $ISSUE_NUMBER --body "‚è≥ **Refining the issue and assigning labels...** (Generated by System ‚ö°)")
          COMMENT_ID=$(echo $COMMENT_URL | grep -oE "[0-9]+$")

          echo "id=$COMMENT_ID" >> $GITHUB_OUTPUT

  process-bug-report:
    name: Process bug-report issue
    needs: initialize-processing
    runs-on: ubuntu-latest
    if: contains(github.event.issue.title, '[Bug]') || contains(join(github.event.issue.labels.*.name), 'BugFix')
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Parse issue form
        uses: stefanbuck/github-issue-parser@v3
        id: issue-parser
        with:
          template-path: .github/ISSUE_TEMPLATE/bug-report.yml

      - name: Update issue content
        env:
          DESCRIPTION: ${{ steps.issue-parser.outputs.issueparser_description }}
          SEVERITY: ${{ steps.issue-parser.outputs.issueparser_severity }}
          FREQUENCY: ${{ steps.issue-parser.outputs.issueparser_frequency }}
          REPRODUCTION: ${{ steps.issue-parser.outputs.issueparser_reproduction }}
          EXPECTED: ${{ steps.issue-parser.outputs.issueparser_expected }}
          BROWSER: ${{ steps.issue-parser.outputs.issueparser_browser }}
          OS: ${{ steps.issue-parser.outputs.issueparser_os }}
          VERSION: ${{ steps.issue-parser.outputs.issueparser_version }}
          EVIDENCE: ${{ steps.issue-parser.outputs.issueparser_evidence }}
          ADDITIONAL: ${{ steps.issue-parser.outputs.issueparser_additional }}
          CHECKLIST: ${{ steps.issue-parser.outputs.issueparser_checklist }}
        run: |
          DEVICE_CONTENT=""
          [ -n "$VERSION" ] && [ "$VERSION" != "_No response_" ] && DEVICE_CONTENT="${DEVICE_CONTENT}**Version**: \`$VERSION\`  "$'\n'
          [ -n "$OS" ] && [ "$OS" != "_No response_" ] && DEVICE_CONTENT="${DEVICE_CONTENT}**OS**: $OS  "$'\n'
          [ -n "$BROWSER" ] && [ "$BROWSER" != "_No response_" ] && DEVICE_CONTENT="${DEVICE_CONTENT}**Browser**: $BROWSER  "

          DEVICE_SECTION=""
          if [ -n "$DEVICE_CONTENT" ]; then
            DEVICE_SECTION="<br />"$'\n'$'\n'"## ‚öôÔ∏è Device Information"$'\n'$'\n'"$DEVICE_CONTENT"
          fi

          REF_SECTION=""
          if [ -n "$EVIDENCE" ] && [ "$EVIDENCE" != "_No response_" ]; then
            REF_SECTION="<br />"$'\n'$'\n'"## üí¨ Reference (Screenshots, Logs, URLs, etc.)"$'\n\n'"$EVIDENCE"$'\n'
          fi

          ADDITIONAL_SECTION=""
          if [ -n "$ADDITIONAL" ] && [ "$ADDITIONAL" != "_No response_" ]; then
            ADDITIONAL_SECTION="---"$'\n'$'\n'"### ‚ûï Additional Information"$'\n\n'"$ADDITIONAL"$''
          fi

          CHECKLIST_OPTIONS=$(awk '
            $0 ~ /^  - type: checkboxes$/ {in_checkbox=1; next}
            in_checkbox && $0 ~ /^  - type:/ {in_checkbox=0}
            in_checkbox && $0 ~ /^    id: checklist$/ {is_target=1; next}
            in_checkbox && $0 ~ /^    id:/ && $0 !~ /^    id: checklist$/ {is_target=0}
            in_checkbox && is_target && $0 ~ /^        - label:/ {
              sub(/^        - label:[[:space:]]*/, "", $0)
              print
            }
          ' .github/ISSUE_TEMPLATE/bug-report.yml)

          CHECKLIST_SECTION=""
          CHECKLIST_RENDERED=""
          if [ -n "$CHECKLIST_OPTIONS" ]; then
            while IFS= read -r OPTION; do
              [ -z "$OPTION" ] && continue

              ESCAPED_OPTION=$(printf '%s\n' "$OPTION" | sed 's/[][(){}.^$*+?|\\/]/\\&/g')

              if [ -n "$CHECKLIST" ] && [ "$CHECKLIST" != "_No response_" ] && printf '%s\n' "$CHECKLIST" | grep -Eiq "\\[[xX]\\][[:space:]]*$ESCAPED_OPTION([[:space:]]*)$"; then
                CHECKLIST_RENDERED="${CHECKLIST_RENDERED}- [x] $OPTION"$'\n'
              elif [ -n "$CHECKLIST" ] && [ "$CHECKLIST" != "_No response_" ] && printf '%s\n' "$CHECKLIST" | grep -Eiq "\\[[[:space:]]\\][[:space:]]*$ESCAPED_OPTION([[:space:]]*)$"; then
                CHECKLIST_RENDERED="${CHECKLIST_RENDERED}- [ ] $OPTION"$'\n'
              elif [ -n "$CHECKLIST" ] && [ "$CHECKLIST" != "_No response_" ] && printf '%s\n' "$CHECKLIST" | grep -Fqi "$OPTION"; then
                CHECKLIST_RENDERED="${CHECKLIST_RENDERED}- [x] $OPTION"$'\n'
              else
                CHECKLIST_RENDERED="${CHECKLIST_RENDERED}- [ ] $OPTION"$'\n'
              fi
            done <<< "$CHECKLIST_OPTIONS"

            CHECKLIST_SECTION="---"$'\n'$'\n'"### ‚úÖ Checklist"$'\n\n'"$CHECKLIST_RENDERED"
          fi

          NEW_BODY=$(cat <<EOF
          > **Severity:** $SEVERITY
          > **Frequency:** $FREQUENCY

          <br />

          ## üîç Description

          $DESCRIPTION

          <br />

          ## ‚ùì Steps to Reproduce

          $REPRODUCTION

          <br />

          ## üéØ Expected Behavior

          $EXPECTED

          $DEVICE_SECTION

          $REF_SECTION
          $ADDITIONAL_SECTION
          $CHECKLIST_SECTION

          <br />

          > ‚ö° Generated by **GitHub Actions**
          EOF
          )

          LABEL_NAME=$(echo "$SEVERITY" | sed 's/[^a-zA-Z ]//g' | awk '{print $1}')

          gh issue edit $ISSUE_NUMBER --body "$NEW_BODY" --add-label="$LABEL_NAME"

  process-feature-request:
    name: Process feature-request issue
    needs: initialize-processing
    runs-on: ubuntu-latest
    if: contains(github.event.issue.title, '[Feature]') || contains(join(github.event.issue.labels.*.name), 'Feature')
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Parse issue form
        uses: stefanbuck/github-issue-parser@v3
        id: issue-parser
        with:
          template-path: .github/ISSUE_TEMPLATE/feature-request.yml

      - name: Update issue content
        env:
          TYPE: ${{ steps.issue-parser.outputs.issueparser_type }}
          CONTEXT: ${{ steps.issue-parser.outputs.issueparser_context }}
          SOLUTION: ${{ steps.issue-parser.outputs.issueparser_solution }}
          ALTERNATIVE: ${{ steps.issue-parser.outputs.issueparser_alternative }}
          EXAMPLE: ${{ steps.issue-parser.outputs.issueparser_example }}
          PRIORITY: ${{ steps.issue-parser.outputs.issueparser_priority }}
          USER_GROUP: ${{ steps.issue-parser.outputs.issueparser_user_group }}
          COMPATIBILITY_IMPACT: ${{ steps.issue-parser.outputs.issueparser_compatibility_impact }}
          REFERENCE: ${{ steps.issue-parser.outputs.issueparser_reference }}
          ADDITIONAL: ${{ steps.issue-parser.outputs.issueparser_additional }}
          CHECKLIST: ${{ steps.issue-parser.outputs.issueparser_checklist }}
        run: |
          METADATA_SECTION=""
          [ -n "$USER_GROUP" ] && [ "$USER_GROUP" != "_No response_" ] && METADATA_SECTION="${METADATA_SECTION}> **Target**: $USER_GROUP"$'\n'
          [ -n "$COMPATIBILITY_IMPACT" ] && [ "$COMPATIBILITY_IMPACT" != "_No response_" ] && METADATA_SECTION="${METADATA_SECTION}> **Compatibility Impact**: $COMPATIBILITY_IMPACT"$'\n'
          METADATA_SECTION="${METADATA_SECTION}"$'\n'"<br />"

          OPTIONAL_DETAILS="<br />"
          [ -n "$ALTERNATIVE" ] && [ "$ALTERNATIVE" != "_No response_" ] && OPTIONAL_DETAILS="${OPTIONAL_DETAILS}"$'\n\n'"### ‚òëÔ∏è Alternative Considered"$'\n\n'"$ALTERNATIVE"
          [ -n "$EXAMPLE" ] && [ "$EXAMPLE" != "_No response_" ] && OPTIONAL_DETAILS="${OPTIONAL_DETAILS}"$'\n\n'"### üöÄ Usage Example"$'\n\n'"$EXAMPLE"
          [ -n "$REFERENCE" ] && [ "$REFERENCE" != "_No response_" ] && OPTIONAL_DETAILS="${OPTIONAL_DETAILS}"$'\n\n'"### üí¨ Reference"$'\n\n'"$REFERENCE"
          [ -n "$ADDITIONAL" ] && [ "$ADDITIONAL" != "_No response_" ] && OPTIONAL_DETAILS="${OPTIONAL_DETAILS}"$'\n\n'"### ‚ûï Additional Information"$'\n\n'"$ADDITIONAL"

          CHECKLIST_OPTIONS=$(awk '
            $0 ~ /^  - type: checkboxes$/ {in_checkbox=1; next}
            in_checkbox && $0 ~ /^  - type:/ {in_checkbox=0}
            in_checkbox && $0 ~ /^    id: checklist$/ {is_target=1; next}
            in_checkbox && $0 ~ /^    id:/ && $0 !~ /^    id: checklist$/ {is_target=0}
            in_checkbox && is_target && $0 ~ /^        - label:/ {
              sub(/^        - label:[[:space:]]*/, "", $0)
              print
            }
          ' .github/ISSUE_TEMPLATE/feature-request.yml)

          CHECKLIST_SECTION=""
          CHECKLIST_RENDERED=""
          if [ -n "$CHECKLIST_OPTIONS" ]; then
            while IFS= read -r OPTION; do
              [ -z "$OPTION" ] && continue

              ESCAPED_OPTION=$(printf '%s\n' "$OPTION" | sed 's/[][(){}.^$*+?|\\/]/\\&/g')

              if [ -n "$CHECKLIST" ] && [ "$CHECKLIST" != "_No response_" ] && printf '%s\n' "$CHECKLIST" | grep -Eiq "\\[[xX]\\][[:space:]]*$ESCAPED_OPTION([[:space:]]*)$"; then
                CHECKLIST_RENDERED="${CHECKLIST_RENDERED}- [x] $OPTION"$'\n'
              elif [ -n "$CHECKLIST" ] && [ "$CHECKLIST" != "_No response_" ] && printf '%s\n' "$CHECKLIST" | grep -Eiq "\\[[[:space:]]\\][[:space:]]*$ESCAPED_OPTION([[:space:]]*)$"; then
                CHECKLIST_RENDERED="${CHECKLIST_RENDERED}- [ ] $OPTION"$'\n'
              elif [ -n "$CHECKLIST" ] && [ "$CHECKLIST" != "_No response_" ] && printf '%s\n' "$CHECKLIST" | grep -Fqi "$OPTION"; then
                CHECKLIST_RENDERED="${CHECKLIST_RENDERED}- [x] $OPTION"$'\n'
              else
                CHECKLIST_RENDERED="${CHECKLIST_RENDERED}- [ ] $OPTION"$'\n'
              fi
            done <<< "$CHECKLIST_OPTIONS"

            CHECKLIST_SECTION="---"$'\n\n'"### ‚úÖ Checklist"$'\n\n'"$CHECKLIST_RENDERED"$'\n'"<br />"
          fi

          NEW_BODY=$(cat <<EOF
          > **Type**: $TYPE
          > **Priority**: $PRIORITY
          $METADATA_SECTION

          ## ‚ùì Problem Statement

          $PROBLEM

          <br />

          ## üí° Proposed Solution

          $SOLUTION

          $OPTIONAL_DETAILS

          $CHECKLIST_SECTION

          > ‚ö° Generated by **GitHub Actions**
          EOF
          )

          gh issue edit $ISSUE_NUMBER --body "$NEW_BODY"

  process-general:
    name: Process general issue
    needs: initialize-processing
    runs-on: ubuntu-latest
    if: ${{ !contains(github.event.issue.title, '[Bug]') && !contains(github.event.issue.labels.*.name, 'BugFix') && !contains(github.event.issue.title, '[Feature]') && !contains(github.event.issue.labels.*.name, 'Feature') }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Parse issue form
        uses: stefanbuck/github-issue-parser@v3
        id: issue-parser
        with:
          template-path: .github/ISSUE_TEMPLATE/general.yml

      - name: Update issue content
        env:
          SUMMARY: ${{ steps.issue-parser.outputs.issueparser_summary }}
          DESCRIPTION: ${{ steps.issue-parser.outputs.issueparser_description }}
          EXPECTED: ${{ steps.issue-parser.outputs.issueparser_expected }}
          REFERENCE: ${{ steps.issue-parser.outputs.issueparser_reference }}
          ADDITIONAL: ${{ steps.issue-parser.outputs.issueparser_additional }}
          CHECKLIST: ${{ steps.issue-parser.outputs.issueparser_checklist }}
        run: |
          OPTIONAL_DETAILS="<br />"
          [ -n "$EXPECTED" ] && [ "$EXPECTED" != "_No response_" ] && OPTIONAL_DETAILS="${OPTIONAL_DETAILS}"$'\n\n'"### üéØ Expected Outcome"$'\n\n'"$EXPECTED"
          [ -n "$REFERENCE" ] && [ "$REFERENCE" != "_No response_" ] && OPTIONAL_DETAILS="${OPTIONAL_DETAILS}"$'\n\n'"### üí¨ Reference"$'\n\n'"$REFERENCE"
          [ -n "$ADDITIONAL" ] && [ "$ADDITIONAL" != "_No response_" ] && OPTIONAL_DETAILS="${OPTIONAL_DETAILS}"$'\n\n'"### ‚ûï Additional Information"$'\n\n'"$ADDITIONAL"

          CHECKLIST_OPTIONS=$(awk '
            $0 ~ /^  - type: checkboxes$/ {in_checkbox=1; next}
            in_checkbox && $0 ~ /^  - type:/ {in_checkbox=0}
            in_checkbox && $0 ~ /^    id: checklist$/ {is_target=1; next}
            in_checkbox && $0 ~ /^    id:/ && $0 !~ /^    id: checklist$/ {is_target=0}
            in_checkbox && is_target && $0 ~ /^        - label:/ {
              sub(/^        - label:[[:space:]]*/, "", $0)
              print
            }
          ' .github/ISSUE_TEMPLATE/general.yml)

          CHECKLIST_SECTION=""
          CHECKLIST_RENDERED=""
          if [ -n "$CHECKLIST_OPTIONS" ]; then
            while IFS= read -r OPTION; do
              [ -z "$OPTION" ] && continue

              ESCAPED_OPTION=$(printf '%s\n' "$OPTION" | sed 's/[][(){}.^$*+?|\\/]/\\&/g')

              if [ -n "$CHECKLIST" ] && [ "$CHECKLIST" != "_No response_" ] && printf '%s\n' "$CHECKLIST" | grep -Eiq "\\[[xX]\\][[:space:]]*$ESCAPED_OPTION([[:space:]]*)$"; then
                CHECKLIST_RENDERED="${CHECKLIST_RENDERED}- [x] $OPTION"$'\n'
              elif [ -n "$CHECKLIST" ] && [ "$CHECKLIST" != "_No response_" ] && printf '%s\n' "$CHECKLIST" | grep -Eiq "\\[[[:space:]]\\][[:space:]]*$ESCAPED_OPTION([[:space:]]*)$"; then
                CHECKLIST_RENDERED="${CHECKLIST_RENDERED}- [ ] $OPTION"$'\n'
              elif [ -n "$CHECKLIST" ] && [ "$CHECKLIST" != "_No response_" ] && printf '%s\n' "$CHECKLIST" | grep -Fqi "$OPTION"; then
                CHECKLIST_RENDERED="${CHECKLIST_RENDERED}- [x] $OPTION"$'\n'
              else
                CHECKLIST_RENDERED="${CHECKLIST_RENDERED}- [ ] $OPTION"$'\n'
              fi
            done <<< "$CHECKLIST_OPTIONS"

            CHECKLIST_SECTION="---"$'\n\n'"### ‚úÖ Checklist"$'\n\n'"$CHECKLIST_RENDERED"$'\n'"<br />"
          fi

          NEW_BODY=$(cat <<EOF
           ## üìå Summary

           $SUMMARY

           <br />

           ## üîç Description

           $DESCRIPTION

           $OPTIONAL_DETAILS

           $CHECKLIST_SECTION

          > ‚ö° Generated by **GitHub Actions**
          EOF
          )

          gh issue edit $ISSUE_NUMBER --body "$NEW_BODY"

  finalize-processing:
    name: Finalize processing
    needs:
      [
        initialize-processing,
        process-bug-report,
        process-feature-request,
        process-general,
      ]
    runs-on: ubuntu-latest
    if: always()
    env:
      REPO: ${{ github.repository }}
      COMMENT_ID: ${{ needs.initialize-processing.outputs.comment-id }}
      CATEGORY: ${{ needs.initialize-processing.outputs.category }}
      RESULT: ${{ ((needs.initialize-processing.outputs.category == 'bug-report' && needs.process-bug-report.result == 'success') || (needs.initialize-processing.outputs.category == 'feature-request' && needs.process-feature-request.result == 'success') || (needs.initialize-processing.outputs.category == 'general' && needs.process-general.result == 'success')) && 'success' || 'failure'  }}
    steps:
      - name: Add final comment
        run: |
          COMMENT_BODY="‚úÖ **Processing completed!** Labels have been synchronized and applied based on the issue content."
          if [ "$RESULT" != "success" ]; then
             COMMENT_BODY="‚ö†Ô∏è **Processing failed!** There was an error while formatting the issue. Please check the issue content and labels for correctness."              
          fi

          gh api -X PATCH "repos/${REPO}/issues/comments/${COMMENT_ID}" \
            -f body="${COMMENT_BODY}"
